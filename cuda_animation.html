<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA Execution Model Animation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #00ff88; margin-bottom: 10px; font-size: 1.8rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 30px; }
        
        .controls {
            display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;
        }
        .btn {
            padding: 12px 30px; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1rem; font-weight: 600; transition: all 0.3s;
        }
        .btn-primary { background: #00ff88; color: #000; }
        .btn-primary:hover { background: #00cc6a; transform: scale(1.05); }
        .btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }
        .btn-danger { background: #ff6b6b; color: #fff; }
        .btn-danger:hover { background: #ee5a5a; }
        
        .stage-box {
            text-align: center; padding: 15px; margin-bottom: 25px;
            background: rgba(0,212,255,0.1); border: 1px solid #00d4ff;
            border-radius: 10px; color: #00d4ff;
        }
        
        .main-area {
            display: grid; grid-template-columns: 180px 1fr;
            gap: 25px;
        }
        @media (max-width: 800px) {
            .main-area { grid-template-columns: 1fr; }
        }
        
        .queue-panel, .sm-panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 20px;
        }
        .panel-title {
            font-weight: 600; margin-bottom: 15px;
            padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #fbbf24;
        }
        
        .block-queue {
            display: flex; flex-direction: column; gap: 8px;
        }
        .block {
            width: 55px; height: 45px; border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 600; font-size: 0.85rem;
            transition: all 0.4s ease;
        }
        .block.queued { background: rgba(168,85,247,0.4); border: 2px solid #a855f7; color: #a855f7; }
        .block.assigning { background: rgba(251,191,36,0.5); border: 2px solid #fbbf24; color: #000; animation: pulse 0.4s infinite; }
        .block.assigned { background: rgba(0,255,136,0.4); border: 2px solid #00ff88; color: #00ff88; }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        
        .sm-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;
        }
        @media (max-width: 600px) {
            .sm-grid { grid-template-columns: 1fr; }
        }
        
        .sm-box {
            background: rgba(34,197,94,0.1); border: 2px solid #22c55e;
            border-radius: 10px; padding: 15px; min-height: 220px;
        }
        .sm-title { color: #22c55e; font-weight: 600; margin-bottom: 12px; font-size: 1.1rem; }
        
        .sm-blocks {
            display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 12px; min-height: 50px;
        }
        .sm-block {
            width: 40px; height: 35px; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.7rem; font-weight: 600;
            background: rgba(0,255,136,0.3); border: 1px solid #00ff88; color: #00ff88;
            animation: popIn 0.4s ease;
        }
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .resource-bar-container { margin: 10px 0; }
        .resource-label { font-size: 0.75rem; color: #888; margin-bottom: 4px; }
        .resource-bar {
            height: 10px; background: rgba(255,255,255,0.1);
            border-radius: 5px; overflow: hidden;
        }
        .resource-fill {
            height: 100%; background: linear-gradient(90deg, #00ff88, #00d4ff);
            border-radius: 5px; transition: width 0.5s ease;
        }
        
        .warp-section { margin-top: 15px; }
        .warp-title { font-size: 0.85rem; color: #00d4ff; margin-bottom: 8px; }
        
        .warp-row {
            display: flex; align-items: center; gap: 10px;
            padding: 6px 10px; margin: 4px 0; border-radius: 5px;
            font-size: 0.8rem; transition: all 0.3s;
        }
        .warp-row.executing {
            background: rgba(0,255,136,0.25); border-left: 3px solid #00ff88;
        }
        .warp-row.ready {
            background: rgba(0,255,136,0.1); border-left: 3px solid rgba(0,255,136,0.5);
        }
        .warp-row.stalled {
            background: rgba(255,107,107,0.2); border-left: 3px solid #ff6b6b;
        }
        .warp-row.waiting {
            background: rgba(251,191,36,0.15); border-left: 3px solid #fbbf24;
        }
        
        .warp-name { width: 30px; font-weight: 600; }
        .warp-threads { display: flex; gap: 2px; }
        .thread-dot {
            width: 5px; height: 14px; border-radius: 2px;
            transition: background 0.2s;
        }
        .thread-dot.active { background: #00ff88; }
        .thread-dot.inactive { background: rgba(255,255,255,0.15); }
        .warp-status { font-size: 0.7rem; margin-left: auto; }
        
        .cycle-counter {
            position: fixed; top: 20px; right: 20px;
            background: rgba(0,0,0,0.85); padding: 15px 25px;
            border-radius: 10px; border: 2px solid #00ff88;
            text-align: center; display: none;
        }
        .cycle-counter.visible { display: block; }
        .cycle-num { font-size: 2.5rem; color: #00ff88; font-weight: 700; }
        .cycle-label { font-size: 0.8rem; color: #888; }
        
        .legend {
            display: flex; gap: 25px; justify-content: center;
            margin-top: 25px; flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: #888; }
        .legend-box { width: 20px; height: 14px; border-radius: 3px; }
        
        .insight-box {
            margin-top: 30px; padding: 20px;
            background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b;
            border-radius: 10px;
        }
        .insight-title { color: #ff6b6b; font-weight: 600; margin-bottom: 10px; }
        .insight-text { color: #888; line-height: 1.6; }
        
        .back-link {
            display: inline-block; margin-top: 25px; color: #00d4ff;
            text-decoration: none;
        }
        .back-link:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>CUDA Execution Model Animation</h1>
        <p class="subtitle">Visualizing Block Assignment to SMs and Warp Scheduling</p>
        
        <div class="controls">
            <button class="btn btn-primary" id="startBtn" onclick="startAnimation()">‚ñ∂ Start Animation</button>
            <button class="btn btn-danger" onclick="resetAnimation()">‚Ü∫ Reset</button>
        </div>
        
        <div class="stage-box" id="stageBox">Press "Start Animation" to begin</div>
        
        <div class="cycle-counter" id="cycleCounter">
            <div class="cycle-num" id="cycleNum">0</div>
            <div class="cycle-label">Clock Cycles</div>
        </div>
        
        <div class="main-area">
            <div class="queue-panel">
                <div class="panel-title">üì¶ Block Queue</div>
                <div class="block-queue" id="blockQueue"></div>
            </div>
            
            <div class="sm-panel">
                <div class="panel-title">üñ•Ô∏è Streaming Multiprocessors</div>
                <div class="sm-grid" id="smGrid"></div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item"><div class="legend-box" style="background: #a855f7;"></div> Queued</div>
            <div class="legend-item"><div class="legend-box" style="background: #fbbf24;"></div> Assigning</div>
            <div class="legend-item"><div class="legend-box" style="background: #00ff88;"></div> Assigned / Executing</div>
            <div class="legend-item"><div class="legend-box" style="background: #ff6b6b;"></div> Stalled</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(251,191,36,0.5);"></div> Waiting</div>
        </div>
        
        <div class="insight-box">
            <div class="insight-title">üí° Key Insight: Latency Hiding</div>
            <div class="insight-text">
                When a warp issues a memory read (from global memory or storage), it transitions to <strong style="color:#ff6b6b">STALLED</strong>. 
                The warp scheduler immediately switches to another <strong style="color:#00ff88">READY</strong> warp to keep the CUDA cores busy.
                This is how GPUs hide memory latency. But if <strong style="color:#ff6b6b">ALL warps are stalled</strong> waiting on I/O, 
                the entire SM sits idle ‚Äî this is why storage access patterns and latency matter for GPU efficiency!
            </div>
        </div>
        
        <a href="02_cpu_vs_gpu.html" class="back-link">‚Üê Back to CPU vs GPU Architecture</a>
    </div>
    
    <script>
        // State
        var blocks = [];
        var sms = [];
        var stage = 0;
        var cycle = 0;
        var animationInterval = null;
        var isRunning = false;
        
        var warpColors = ['#00ff88', '#3b82f6', '#f97316', '#a855f7'];
        var stageMessages = [
            'Press "Start Animation" to begin',
            'Stage 1: Assigning Thread Blocks to SMs...',
            'Stage 2: Warp Scheduling ‚Äî Watch how the scheduler hides latency!',
            'Animation Complete! Notice how warp switching kept SMs busy despite stalls.'
        ];
        
        // Initialize
        function init() {
            blocks = [];
            for (var i = 0; i < 8; i++) {
                blocks.push({ id: i, name: 'B' + i, status: 'queued', sm: null });
            }
            
            sms = [];
            for (var i = 0; i < 4; i++) {
                sms.push({
                    id: i, name: 'SM ' + i, blocks: [], registers: 0,
                    warps: []
                });
            }
            
            render();
        }
        
        // Render block queue
        function renderBlockQueue() {
            var queue = document.getElementById('blockQueue');
            var html = '';
            for (var i = 0; i < blocks.length; i++) {
                html += '<div class="block ' + blocks[i].status + '">' + blocks[i].name + '</div>';
            }
            queue.innerHTML = html;
        }
        
        // Render SMs
        function renderSMs() {
            var grid = document.getElementById('smGrid');
            var html = '';
            
            for (var s = 0; s < sms.length; s++) {
                var sm = sms[s];
                html += '<div class="sm-box">';
                html += '<div class="sm-title">' + sm.name + '</div>';
                html += '<div class="sm-blocks">';
                for (var b = 0; b < sm.blocks.length; b++) {
                    html += '<div class="sm-block">' + sm.blocks[b].name + '</div>';
                }
                html += '</div>';
                html += '<div class="resource-bar-container">';
                html += '<div class="resource-label">Register Usage: ' + sm.registers + '%</div>';
                html += '<div class="resource-bar"><div class="resource-fill" style="width: ' + sm.registers + '%"></div></div>';
                html += '</div>';
                
                if (sm.warps.length > 0) {
                    html += '<div class="warp-section">';
                    html += '<div class="warp-title">Warp Scheduler</div>';
                    for (var w = 0; w < sm.warps.length; w++) {
                        var warp = sm.warps[w];
                        html += '<div class="warp-row ' + warp.status + '">';
                        html += '<span class="warp-name" style="color: ' + warpColors[w] + '">' + warp.name + '</span>';
                        html += '<div class="warp-threads">';
                        for (var t = 0; t < 16; t++) {
                            var dotClass = warp.status === 'executing' ? 'active' : 'inactive';
                            html += '<div class="thread-dot ' + dotClass + '"></div>';
                        }
                        html += '</div>';
                        html += '<span class="warp-status">' + getStatusIcon(warp.status) + '</span>';
                        html += '</div>';
                    }
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            grid.innerHTML = html;
        }
        
        function getStatusIcon(status) {
            if (status === 'executing') return '‚ñ∂ EXEC';
            if (status === 'ready') return '‚óè READY';
            if (status === 'stalled') return '‚è∏ STALL';
            if (status === 'waiting') return '‚è≥ WAIT';
            return '';
        }
        
        function render() {
            renderBlockQueue();
            renderSMs();
            document.getElementById('stageBox').textContent = stageMessages[stage];
            document.getElementById('cycleNum').textContent = cycle;
        }
        
        // Start animation
        function startAnimation() {
            if (isRunning) return;
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            
            init();
            stage = 1;
            render();
            
            // Stage 1: Block assignment
            var blockIdx = 0;
            animationInterval = setInterval(function() {
                if (blockIdx < 8) {
                    var smIdx = blockIdx % 4;
                    blocks[blockIdx].status = 'assigned';
                    blocks[blockIdx].sm = smIdx;
                    
                    sms[smIdx].blocks.push({ name: blocks[blockIdx].name });
                    sms[smIdx].registers = Math.min(100, sms[smIdx].registers + 40);
                    
                    // Add warps for this block
                    if (sms[smIdx].warps.length === 0) {
                        sms[smIdx].warps = [
                            { id: 0, name: 'W0', status: 'ready' },
                            { id: 1, name: 'W1', status: 'ready' },
                            { id: 2, name: 'W2', status: 'ready' },
                            { id: 3, name: 'W3', status: 'ready' }
                        ];
                    }
                    
                    render();
                    blockIdx++;
                } else {
                    clearInterval(animationInterval);
                    setTimeout(startWarpScheduling, 800);
                }
            }, 500);
        }
        
        // Stage 2: Warp scheduling
        function startWarpScheduling() {
            stage = 2;
            cycle = 0;
            document.getElementById('cycleCounter').classList.add('visible');
            render();
            
            animationInterval = setInterval(function() {
                cycle++;
                
                // Update warp states for each SM
                for (var s = 0; s < sms.length; s++) {
                    var sm = sms[s];
                    if (sm.warps.length === 0) continue;
                    
                    // Update each warp's state
                    for (var w = 0; w < sm.warps.length; w++) {
                        var warp = sm.warps[w];
                        var rand = Math.random();
                        
                        if (warp.status === 'executing') {
                            warp.status = rand > 0.5 ? 'stalled' : 'ready';
                        } else if (warp.status === 'stalled') {
                            warp.status = rand > 0.6 ? 'ready' : 'stalled';
                        } else if (warp.status === 'waiting') {
                            warp.status = rand > 0.7 ? 'ready' : 'waiting';
                        }
                    }
                    
                    // Scheduler picks a ready warp to execute
                    for (var w = 0; w < sm.warps.length; w++) {
                        if (sm.warps[w].status === 'ready') {
                            sm.warps[w].status = 'executing';
                            break;
                        }
                    }
                }
                
                render();
                
                // Stop after 15 cycles
                if (cycle >= 15) {
                    clearInterval(animationInterval);
                    stage = 3;
                    isRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    render();
                }
            }, 700);
        }
        
        // Reset
        function resetAnimation() {
            clearInterval(animationInterval);
            isRunning = false;
            stage = 0;
            cycle = 0;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('cycleCounter').classList.remove('visible');
            init();
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
