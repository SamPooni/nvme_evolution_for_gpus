<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03 - Thread Synchronization Crisis | NVMe for GPUs</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10,10,15,0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .nav a { color: #888; text-decoration: none; transition: color 0.3s; }
        .nav a:hover { color: #00ff88; }
        .nav-title { color: #fff; font-weight: 600; }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 100px 20px 40px;
        }
        .page-header { text-align: center; margin-bottom: 50px; }
        .page-number { font-size: 5rem; font-weight: 700; color: rgba(255,255,255,0.05); line-height: 1; }
        .page-title { font-size: 2.5rem; font-weight: 700; color: #ff6b6b; margin-top: -30px; }
        .page-subtitle { color: #888; margin-top: 10px; font-size: 1.1rem; }
        .section {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 40px;
        }
        .section-title {
            font-size: 1.5rem;
            color: #fbbf24;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: #fbbf24;
            border-radius: 2px;
        }
        /* Warp Comparison */
        .warp-compare {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 30px 0;
        }
        @media (max-width: 900px) {
            .warp-compare { grid-template-columns: 1fr; }
        }
        .warp-box {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
        }
        .warp-box.bad {
            border: 2px solid #ff6b6b;
        }
        .warp-box.good {
            border: 2px solid #00ff88;
        }
        .warp-label {
            font-size: 1rem;
            margin-bottom: 20px;
        }
        .warp-visual {
            display: flex;
            gap: 3px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .thread-bar {
            width: 12px;
            height: 50px;
            border-radius: 3px;
        }
        .thread-active { background: #22c55e; }
        .thread-idle { background: #333; }
        .efficiency-text {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 10px;
        }
        .efficiency-text.bad { color: #ff6b6b; }
        .efficiency-text.good { color: #00ff88; }
        /* IO Flow Diagram */
        .io-flow {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 30px 0;
        }
        .flow-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .flow-label {
            width: 120px;
            font-weight: 600;
            color: #888;
        }
        .flow-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }
        .flow-step {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .step-box {
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            flex: 1;
            text-align: center;
        }
        .step-sync {
            background: linear-gradient(135deg, #dc2626, #991b1b);
            color: #fff;
            border: 2px solid #ff6b6b;
        }
        .step-parallel {
            background: linear-gradient(135deg, #16a34a, #15803d);
            color: #fff;
        }
        .step-arrow {
            color: #666;
            font-size: 1.2rem;
        }
        /* Cost Breakdown */
        .cost-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .cost-card {
            background: rgba(255,107,107,0.1);
            border: 1px solid rgba(255,107,107,0.3);
            border-radius: 12px;
            padding: 20px;
        }
        .cost-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .cost-title {
            font-weight: 600;
            color: #ff6b6b;
            margin-bottom: 8px;
        }
        .cost-desc {
            font-size: 0.9rem;
            color: #888;
        }
        .key-point {
            background: rgba(251,191,36,0.1);
            border-left: 4px solid #fbbf24;
            padding: 15px 20px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
        }
        .solution-box {
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            text-align: center;
        }
        .solution-title {
            font-size: 1.3rem;
            color: #00ff88;
            margin-bottom: 15px;
        }
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        .nav-btn {
            padding: 12px 30px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .nav-btn:hover { background: #00ff88; color: #000; }
        .sync-points {
            display: flex;
            flex-direction: column;
            gap: 0;
            margin: 20px 0;
        }
        .sync-row {
            display: flex;
            align-items: stretch;
        }
        .sync-phase {
            width: 100px;
            padding: 15px 10px;
            font-size: 0.8rem;
            color: #888;
            border-right: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sync-steps {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .sync-step {
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .sync-step:last-child {
            border-bottom: none;
        }
        .sync-indicator {
            width: 80px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-align: center;
        }
        .indicator-sync {
            background: #dc2626;
            color: #fff;
        }
        .indicator-parallel {
            background: #16a34a;
            color: #fff;
        }
        .sync-desc {
            flex: 1;
            font-size: 0.9rem;
        }
        .thread-count-section {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .gpu-stat {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 12px;
            flex: 1;
            min-width: 200px;
        }
        .gpu-stat-name {
            color: #00ff88;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .gpu-stat-detail {
            font-size: 0.85rem;
            color: #888;
        }
        .gpu-stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        function App() {
            const [animStep, setAnimStep] = React.useState(0);

            React.useEffect(() => {
                const timer = setInterval(() => {
                    setAnimStep(prev => (prev + 1) % 6);
                }, 1500);
                return () => clearInterval(timer);
            }, []);

            const syncSteps = [
                { phase: 'IO Submission', steps: [
                    { type: 'sync', desc: 'Threads sync to select a unique and non-used NVMe command id' },
                    { type: 'parallel', desc: 'Write commands in SQ in Parallel' },
                    { type: 'sync', desc: 'Threads sync to determine the value to write in the SQ tail doorbell' }
                ]},
                { phase: 'IO Completion', steps: [
                    { type: 'parallel', desc: 'Poll the whole CQ in Parallel' },
                    { type: 'sync', desc: 'Threads sync to determine the value to write in the CQ head doorbell' },
                    { type: 'sync', desc: 'Threads sync to wait for CQ head to pass their completion record position' }
                ]}
            ];

            return (
                <div>
                    <nav className="nav">
                        <a href="02_cpu_vs_gpu.html">&larr; Previous</a>
                        <span className="nav-title">03 - Thread Synchronization Crisis</span>
                        <a href="04_challenges.html">Next: NVMe Challenges &rarr;</a>
                    </nav>

                    <div className="container">
                        <div className="page-header">
                            <div className="page-number">03</div>
                            <h1 className="page-title">Thread Synchronization in NVMe Hurts GPU Utilization</h1>
                            <p className="page-subtitle">Synchronization Challenges</p>
                        </div>

                        {/* Thread Count Reminder */}
                        <div className="section">
                            <h2 className="section-title">The Scale Problem</h2>
                            
                            <div className="thread-count-section">
                                <div className="gpu-stat">
                                    <div className="gpu-stat-name">NVIDIA H200</div>
                                    <div className="gpu-stat-detail">132 SMs &times; 2048 threads/SM</div>
                                    <div className="gpu-stat-value">~270K threads</div>
                                </div>
                                <div className="gpu-stat">
                                    <div className="gpu-stat-name">AMD Instinct MI325X</div>
                                    <div className="gpu-stat-detail">304 CUs &times; 2560 threads/CU</div>
                                    <div className="gpu-stat-value">~778K threads</div>
                                </div>
                            </div>

                            <p style={{color: '#888', marginBottom: '20px'}}>
                                <strong>Note:</strong> Not all threads directly touch NVMe queues. Typically, dedicated I/O-agent warps 
                                (32-128 threads) handle queue submission on behalf of compute threads. However, even these I/O threads 
                                require synchronization when accessing shared SQ/CQ structures, and that synchronization overhead 
                                ripples through the GPU pipeline.
                            </p>
                        </div>

                        {/* Warp Efficiency Comparison */}
                        <div className="section">
                            <h2 className="section-title">Warp Efficiency: Today vs Ideal (Pages 17-18)</h2>
                            
                            <div className="warp-compare">
                                <div className="warp-box bad">
                                    <div className="warp-label">
                                        <span style={{color: '#ff6b6b'}}>Today:</span> When a thread is in sync code
                                    </div>
                                    <div className="warp-visual">
                                        {[...Array(32)].map((_, i) => (
                                            <div 
                                                key={i} 
                                                className={`thread-bar ${i === 0 ? 'thread-active' : 'thread-idle'}`}
                                            ></div>
                                        ))}
                                    </div>
                                    <div style={{color: '#888', fontSize: '0.9rem'}}>
                                        SM can run only 1 thread at each cycle
                                    </div>
                                    <div className="efficiency-text bad">3.125% efficiency</div>
                                    <div style={{color: '#666', fontSize: '0.8rem', marginTop: '5px'}}>
                                        (1 of 32 threads active)
                                    </div>
                                </div>

                                <div className="warp-box good">
                                    <div className="warp-label">
                                        <span style={{color: '#00ff88'}}>Ideal:</span> All 32 threads execute in lock-step
                                    </div>
                                    <div className="warp-visual">
                                        {[...Array(32)].map((_, i) => (
                                            <div key={i} className="thread-bar thread-active"></div>
                                        ))}
                                    </div>
                                    <div style={{color: '#888', fontSize: '0.9rem'}}>
                                        SM runs 32 threads at each cycle (full warp)
                                    </div>
                                    <div className="efficiency-text good">100% efficiency</div>
                                    <div style={{color: '#666', fontSize: '0.8rem', marginTop: '5px'}}>
                                        (32 of 32 threads active)
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Sync Points Diagram */}
                        <div className="section">
                            <h2 className="section-title">Multiple Synchronization Points During I/O (Pages 18-19)</h2>
                            
                            <p style={{color: '#888', marginBottom: '20px'}}>
                                All threads accessing the same I/O queue go through several synchronization loops 
                                (atomic operation + rescheduling) when doing an I/O:
                            </p>

                            <div className="sync-points">
                                {syncSteps.map((phase, phaseIdx) => (
                                    <div key={phaseIdx} className="sync-row">
                                        <div className="sync-phase" style={{
                                            background: phaseIdx === 0 ? 'rgba(251,191,36,0.1)' : 'rgba(0,212,255,0.1)',
                                            color: phaseIdx === 0 ? '#fbbf24' : '#00d4ff'
                                        }}>
                                            {phase.phase}
                                        </div>
                                        <div className="sync-steps">
                                            {phase.steps.map((step, stepIdx) => {
                                                const globalIdx = phaseIdx * 3 + stepIdx;
                                                return (
                                                    <div 
                                                        key={stepIdx} 
                                                        className="sync-step"
                                                        style={{
                                                            background: animStep === globalIdx ? 
                                                                (step.type === 'sync' ? 'rgba(220,38,38,0.2)' : 'rgba(22,163,74,0.2)') : 
                                                                'transparent'
                                                        }}
                                                    >
                                                        <div className={`sync-indicator indicator-${step.type}`}>
                                                            {step.type === 'sync' ? '”’ SYNC' : 'PARALLEL'}
                                                        </div>
                                                        <div className="sync-desc">{step.desc}</div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div style={{textAlign: 'center', marginTop: '20px', padding: '15px', background: 'rgba(255,107,107,0.1)', borderRadius: '8px'}}>
                                <span style={{color: '#ff6b6b', fontWeight: '600'}}>4 out of 6 steps require synchronization</span>
                                <span style={{color: '#888'}}> &mdash; that's 67% of the I/O path!</span>
                            </div>
                        </div>

                        {/* Cost of Synchronization */}
                        <div className="section">
                            <h2 className="section-title">The Cost of Synchronization</h2>
                            
                            <p style={{color: '#888', marginBottom: '20px'}}>
                                Synchronizations are handled via loops that sleep/update GPU memory atomic variables:
                            </p>

                            <div className="cost-grid">
                                <div className="cost-card">
                                    <div className="cost-icon"></div>
                                    <div className="cost-title">Loss of SM Cycles</div>
                                    <div className="cost-desc">Thread serialization means only 1 thread runs instead of 32, wasting 96.875% of compute capacity</div>
                                </div>
                                <div className="cost-card">
                                    <div className="cost-icon">’¾</div>
                                    <div className="cost-title">L1 Cache Impact</div>
                                    <div className="cost-desc">Atomic operations and sync loops impact SM L1 Cache bandwidth</div>
                                </div>
                                <div className="cost-card">
                                    <div className="cost-icon">”„</div>
                                    <div className="cost-title">Excessive Rescheduling</div>
                                    <div className="cost-desc">Each sync loop iteration causes thread rescheduling overhead</div>
                                </div>
                                <div className="cost-card">
                                    <div className="cost-icon">“Š</div>
                                    <div className="cost-title">Memory Overhead</div>
                                    <div className="cost-desc">16 &times; (queue depth) per SQ/CQ pair + 256KB per SSD used for synchronization structures</div>
                                </div>
                            </div>
                        </div>

                        {/* Solution Direction */}
                        <div className="section">
                            <h2 className="section-title">The Path Forward</h2>
                            
                            <div className="solution-box">
                                <div className="solution-title">NVMe Protocol Revisions Can Help</div>
                                <div style={{display: 'flex', gap: '30px', justifyContent: 'center', flexWrap: 'wrap', marginTop: '20px'}}>
                                    <div style={{textAlign: 'center'}}>
                                        <div style={{fontSize: '2rem'}}>“‰</div>
                                        <div style={{color: '#00ff88', fontWeight: '600'}}>Reduce Sync Points</div>
                                    </div>
                                    <div style={{textAlign: 'center'}}>
                                        <div style={{fontSize: '2rem'}}></div>
                                        <div style={{color: '#00ff88', fontWeight: '600'}}>Improve Parallelization</div>
                                    </div>
                                    <div style={{textAlign: 'center'}}>
                                        <div style={{fontSize: '2rem'}}></div>
                                        <div style={{color: '#00ff88', fontWeight: '600'}}>Improve GPU Utilization</div>
                                    </div>
                                </div>
                            </div>

                            <div className="key-point" style={{marginTop: '30px'}}>
                                <strong>Key Insight:</strong> NVMe's control plane assumes a few host threads manage queue submission/completion. 
                                GPUs have thousands of threads that may need storage access, requiring synchronization to 
                                funnel through limited I/O agent warps—this coordination overhead hurts GPU efficiency.
                            </div>
                        </div>

                        {/* Interrupts vs Polling - Pages 21-22 */}
                        <div className="section" style={{background: 'linear-gradient(180deg, rgba(0,212,255,0.05) 0%, transparent 100%)', padding: '30px', borderRadius: '16px', marginTop: '40px'}}>
                            <div style={{display: 'inline-block', background: 'rgba(0, 212, 255, 0.2)', border: '1px solid #00d4ff', borderRadius: '20px', padding: '5px 15px', marginBottom: '15px', fontSize: '0.85rem', color: '#00d4ff'}}>
                                Pages 21-22
                            </div>
                            <h2 className="section-title">Interrupts vs Polling</h2>
                            
                            <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))', gap: '20px', marginTop: '20px'}}>
                                {/* Polling - Good */}
                                <div style={{background: 'rgba(0, 255, 136, 0.1)', border: '2px solid #00ff88', borderRadius: '12px', padding: '20px'}}>
                                    <h3 style={{color: '#00ff88', marginBottom: '15px', fontSize: '1.3rem'}}> Polling (Recommended)</h3>
                                    <p style={{color: '#ccc', marginBottom: '15px', lineHeight: '1.7'}}>
                                        Polling is well suited to parallelization and SIMT architecture. Polling allows threads to 
                                        <strong style={{color: '#00ff88'}}> stay executing in lock steps</strong>, each thread polling a 
                                        distinct completion entry in parallel.
                                    </p>
                                    <div style={{background: 'rgba(0,0,0,0.3)', borderRadius: '8px', padding: '12px'}}>
                                        <p style={{color: '#00ff88', fontWeight: 'bold', marginBottom: '8px'}}>Benefits:</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Maximizes GPU SM scheduler utilization</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Each cycle runs high number of threads</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Maintains SIMT parallelism</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; 32 threads execute together per warp</p>
                                    </div>
                                </div>

                                {/* Interrupts - Bad */}
                                <div style={{background: 'rgba(255, 107, 107, 0.1)', border: '2px solid #ff6b6b', borderRadius: '12px', padding: '20px'}}>
                                    <h3 style={{color: '#ff6b6b', marginBottom: '15px', fontSize: '1.3rem'}}>  Interrupts (Problematic)</h3>
                                    <p style={{color: '#ccc', marginBottom: '15px', lineHeight: '1.7'}}>
                                        If interrupts were used, an interrupt handler would 
                                        <strong style={{color: '#ff6b6b'}}> break the parallelism</strong>. GPUs are designed for 
                                        massively parallel computation, not event-driven control.
                                    </p>
                                    <div style={{background: 'rgba(0,0,0,0.3)', borderRadius: '8px', padding: '12px'}}>
                                        <p style={{color: '#ff6b6b', fontWeight: 'bold', marginBottom: '8px'}}>Problems:</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Handler evicts 32 threads from SM scheduler</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Runs 1 thread instead of 32 per cycle</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Only one thread to handle N completions</p>
                                        <p style={{color: '#aaa', margin: '4px 0'}}>&bull; Requires expensive sync between I/O and handler</p>
                                    </div>
                                </div>
                            </div>

                            {/* Visual Comparison */}
                            <div style={{marginTop: '25px', background: 'rgba(30, 30, 50, 0.6)', borderRadius: '12px', padding: '20px', textAlign: 'center'}}>
                                <h4 style={{color: '#fff', marginBottom: '20px'}}>Thread Execution Comparison</h4>
                                <div style={{display: 'flex', justifyContent: 'center', gap: '60px', flexWrap: 'wrap'}}>
                                    <div>
                                        <p style={{color: '#00ff88', marginBottom: '8px', fontWeight: 'bold'}}>Polling (32 active)</p>
                                        <div style={{display: 'flex', gap: '2px', justifyContent: 'center'}}>
                                            {[...Array(32)].map((_, i) => (
                                                <div key={i} style={{width: '6px', height: '35px', background: '#00ff88', borderRadius: '2px'}} />
                                            ))}
                                        </div>
                                        <p style={{color: '#00ff88', fontSize: '1.2rem', marginTop: '8px', fontWeight: 'bold'}}>100% efficiency</p>
                                    </div>
                                    <div>
                                        <p style={{color: '#ff6b6b', marginBottom: '8px', fontWeight: 'bold'}}>Interrupt Handler (1 active)</p>
                                        <div style={{display: 'flex', gap: '2px', justifyContent: 'center'}}>
                                            <div style={{width: '6px', height: '35px', background: '#ff6b6b', borderRadius: '2px'}} />
                                            {[...Array(31)].map((_, i) => (
                                                <div key={i} style={{width: '6px', height: '35px', background: 'rgba(255,255,255,0.1)', borderRadius: '2px'}} />
                                            ))}
                                        </div>
                                        <p style={{color: '#ff6b6b', fontSize: '1.2rem', marginTop: '8px', fontWeight: 'bold'}}>3.125% efficiency</p>
                                    </div>
                                </div>
                            </div>

                            <div className="key-point" style={{marginTop: '25px', borderColor: '#00d4ff'}}>
                                <strong style={{color: '#00d4ff'}}>Conclusion:</strong> GPUs have no hardware or software to handle interrupt handlers. 
                                Polling maintains SIMT efficiency by keeping all 32 warp threads executing in lock-step, 
                                while interrupts would serialize execution and destroy parallelism.
                            </div>
                        </div>

                        <div className="nav-buttons">
                            <a href="02_cpu_vs_gpu.html" className="nav-btn">&larr; Previous: CPU vs GPU</a>
                            <a href="04_challenges.html" className="nav-btn">Next: Challenges &rarr;</a>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
